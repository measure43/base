#!/bin/zsh
#
# Author:     Ilya Burov
# Version:    1.0
# Date:       13/09/2021
# Platform:   macOS 12.0
# GitHub URL: https://github.com/measure43

# MIT License
#
# Copyright (c) 2021, Ilya Burov, measure43
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


SESSFILE="${HOME}/.sshfstab"

print_help() {
cat << EOF
sshfsctl: Mount SSHFS volumes.

USAGE:
    sshfsctl -m VOLUME
    sshfsctl REMOTE_URI MOUNTPOINT_NAME
    sshfsctl -u MOUNTPOINT_NAME
    sshfsctl [-ahr]

NON-OPTION ARGUMENTS:
    VOLUME
        A name of the volume to mount. See -s and examples.

    REMOTE_URI
        A remote URI to mount. See -s and examples.

OPTIONS:
    -a, --all
        Mounts all volumes from ~/.sshfs_sessions or unmount all mounted
        volumes if used in conjuction with -u

    -m, --mount [VOLUME]
        Mounts the specified volume.
        You can save a volume by adding it to ~/.sshfs_sessions file,
        one volume per row, each row must have the following format:
            VOLUME REMOTE_URI
        E.g.:
            vol0 janedoe@company.com:/home/janedoe

        Will mount janedoe@company.com:/home/janedoe to ~/mnt/vol0

        No whitespace, path separators, "at" signs, dollar signs, etc.
        are allowed in VOLUME. No whitespace is allowed in REMOTE_URI.

        No comments are allowed in ~/.sshfs_sessions file.

        VOLUME is also a mount point name.

        This option has no effect when used in conjuntion with -u

    -u, --umount
        Unmounts the specified mount point or all mounted SSHFS volumes
        if used in conjuction with -a

    -r, -rmdir
        Removes mount directories after unmounting volumes if used in
        conjuction with -u, has no effect otherwise

    -h, --help
        Show this help message and exit

EXAMPLES:
    Open the sess1 session and mount the corresponding remote URI
    to ~/mnt/sess1. See -m
        $ sshfsctl -m sess1

    Unmount the ~/mnt/sess1 mount point
        $ sshfsctl -um sess1

    Mount janedoe@company.com:/home/janedoe to ~/mnt/vol1
        $ sshfsctl janedoe@company.com:/home/janedoe vol1

DEPENDENCIES:
    - macFUSE @ https://osxfuse.github.io/
      Allows you to extend macOS's native file handling capabilities
      via third-party file systems.

    - SSHFS @ https://github.com/libfuse/sshfs
      Allows you to mount a remote filesystem using SFTP.
      Make sure that you have sshfs on your PATH.

    The versions of macFUSE and SSHFS available from Homebrew repositories
    may not work on pre-release versions of mscOS.

COPYRIGHT:
    Copyright (c) 2021, Ilya Burov, measure43

EOF
}

printf_error() {
    printf -- '* ERROR: %s\n' "$(printf ${@})" >&2
}

printf_info() {
    printf -- '- %s\n' "$(printf ${@})"
}


# 1 - what, 2 - where
mount_sshfs() {
    if [[ ${#} -ne 2 ]]; then
        printf_error "mount_sshfs: Wrong number of arguments (%d for %d).\n" ${#} 2
        return 1
    fi

    local _RLOC="${1}"
    local _DIR="${2}"
    local _MNTDIR="${HOME}/mnt/${_DIR}"

    if [[ "${_DIR}" =~ \[/@:\] ]]; then
        printf_error "%s: Bad mount directory name.\n" "${_DIR}"
        return 1
    elif [[ ! -d "${_MNTDIR}" ]]; then
        if ! mkdir -p "${_MNTDIR}" 2> /dev/null; then
            printf_error "%s: Cannot create.\n" "${_MNTDIR}"
            return 1
        fi
    elif [[ ! -r "${_MNTDIR}" ]] || [[ ! -w "${_MNTDIR}" ]] || [[ ! -x "${_MNTDIR}" ]]; then
        printf_error "%s: Insufficient permissions to mount to directory.\n" "${_MNTDIR}"
        return 1
    fi

    if ! sshfs -o allow_other,default_permissions,follow_symlinks,disable_hardlink "${_RLOC}" "${_MNTDIR}"; then
        printf_error "Failed to mount remote file system %s to local directory %s\n" "${_RLOC}" "${_MNTDIR}"
        return 1
    fi
    printf "Successfully mounted remote file system %s to local directory %s\n" "${_RLOC}" "${_MNTDIR}"
}

unmount_sshfs() {
    local _RET=1
    if [[ ${#} -eq 0 ]]; then
        if umount -at sshfs; then
            printf "Successfully unmounted all SSHFS volumes.\n"
            while read MNT; do
                rmdir -- "${MNT}" 2> /dev/null
            done < <(find "${HOME}/mnt" -mindepth 1 -maxdepth 1 -type d -print)
            _RET=0
        else
            printf_error "Failed to unmount one or more SSHFS volumes.\n"
        fi
    else
        local _CNT_TOTAL=0
        local _CNT_UNMOUNTED=0
        for _DIR in "${@}"; do
            ((_CNT_TOTAL++))
            local _MNTDIR="${HOME}/mnt/${_DIR}"

            if [[ "${_DIR}" =~ \[/@:\] ]]; then
                printf_error "%s: Bad mount directory name.\n" "${_DIR}"
            elif [[ ! -d "${_MNTDIR}" ]]; then
                printf_error "%s: No such directory.\n" "${_MNTDIR}"
            fi

            if ! umount -vf -- "${_MNTDIR}"; then
                printf_error "%s: Failed to unmout directory.\n" "${_MNTDIR}"
            else
                ((_CNT_UNMOUNTED++))
                rmdir -- "${_MNTDIR}" 2> /dev/null
                printf "Successfully unmounted %s.\n" "${_MNTDIR}"
            fi
        done
    fi

    if [[ $_CNT_TOTAL -eq $_CNT_UNMOUNTED ]]; then
        _RET=0
    fi
    return $_RET


}

get_session() {
    if ! touch "${SESSFILE}"; then
        printf_error "%s: Cannot to create or update SSHFS file systems table.\n" "${SESSFILE}"
        return 1
    fi

    if [[ ${#} -ne 1 ]]; then
        printf_error "get_session: Wrong number of arguments (%d for %d).\n" ${#} 1
        return 1
    fi

    local _SESSID="${1}"
    if ! grep -qE '^\s*'"${_SESSID}"'\s+' "${SESSFILE}"; then
        printf_error "%s: No such session.\n" "${_SESSID}"
        return 1
    elif [[ $(grep -cE '^\s*'"${_SESSID}"'\s+' "${SESSFILE}") -gt 1 ]]; then
        printf_error "%s: Session name is not unique.\n" "${_SESSID}"
        return 1
    elif ! awk -v VOL_NAME="${_SESSID}" '{if ($1 == VOL_NAME && NF != 2) exit 1}' "${SESSFILE}"; then
        printf_error "%s: Bad format of session details.\n" "${_SESSID}"
        return 1
    fi

     awk -v VOL_NAME="${_SESSID}" '{if ($1 == VOL_NAME && NF == 2) {print $2, $1; exit 0}}' "${SESSFILE}"
}


OPTSPEC='huam:-:'
OPT_UMOUNT=false
OPT_MOUNT=false
OPT_ALL=false
unset VOL_NAME
while getopts $OPTSPEC OPTCH; do
    case $OPTCH in
        h)
            print_help
            exit 0
        ;;
        a)
            OPT_ALL=true
        ;;
        m)
            OPT_MOUNT=true
            VOL_NAME="${OPTARG}"
            if [[ ${VOL_NAME:0:1} == '-' ]]; then
                printf_error "No options are allowed after -%s.\n" $OPTCH
                print_help >&2
                exit 1
            fi
        ;;
        u)
            OPT_UMOUNT=true
        ;;
        -)
            case $OPTARG in
                help)
                    print_help
                    exit 0
                ;;
                all)
                    OPT_ALL=true
                ;;
                umount|unmount)
                    # unmount, right?
                    OPT_UMOUNT=true
                ;;
                mount)
                    OPT_MOUNT=true
                    declare -a _TMPARG=( "${@}" )
                    VOL_NAME="${_TMPARG[$((OPTIND))]}"
                    shift
                    unset _TMPARG

                    if [[ -z "${VOL_NAME}" ]]; then
                        printf_error "Argument is expected after --%s.\n" $OPTARG
                        print_help >&2
                        exit 1
                    elif [[ ${VOL_NAME:0:1} == '-' ]]; then
                        printf_error "No options are allowed after --%s.\n" $OPTARG
                        print_help >&2
                        exit 1
                    fi

                ;;
            esac

        ;;
        *)
            print_help >&2
            exit 1
        ;;
    esac
done

shift $((OPTIND - 1))


if ! command -v sshfs > /dev/null; then
    printf_error 'sshfs: Command not found. %s requires macFUSE and SSHFS.\n' $0
    print_help >&2
    exit 1
fi

ST_EXIT=0
ST_MOUNTED_SINGLE=false
if $OPT_UMOUNT; then
    if $OPT_ALL; then
        unmount_sshfs
    elif [[ -n ${VOL_NAME} ]]; then
        if get_session "${VOL_NAME}" > /dev/null; then
            unmount_sshfs $(get_session "${VOL_NAME}" | awk '{print $2}')
        else
            ST_EXIT=1
        fi
    elif [[ ${#} -ne 1 ]]; then
        printf_error "Wrong number of arguments (%d for %d). Expected a volume or a mount point name.\n" ${#} 1
        print_help
        ST_EXIT=1
    else
        unmount_sshfs ${1}
    fi
elif $OPT_MOUNT; then
    if $OPT_ALL; then
        if ! touch "${SESSFILE}"; then
            printf_error "%s: Cannot to create or update SSHFS file systems table.\n" "${SESSFILE}"
            return 1
        fi

        CNT_SUCCESS=0
        CNT_FAIL=0
        while read VOL_NAME; do
            if get_session "${VOL_NAME}" > /dev/null; then
                mount_sshfs $(get_session "${VOL_NAME}") && ((CNT_SUCCESS++)) || ((CNT_FAIL++))
            fi
        done < <(awk '{print $1}' "${SESSFILE}")

        if [[ ${CNT_SUCCESS} -ge 0 ]]; then
            printf 'Mounted %d volume(s).\n' ${CNT_SUCCESS}
        fi

        if [[ ${CNT_FAIL} -gt 0 ]]; then
            printf 'Failed to mount %d volume(s).\n' ${CNT_FAIL}
            ST_EXIT=1
        fi

    elif [[ -z "${VOL_NAME}" && ${#} -ne 2 ]] || [[ -n "${VOL_NAME}" && ${#} -eq 2 ]]; then
        printf_error "Expected a volume name or a mount point and remote node URI.\n"
        print_help
        ST_EXIT=1
    elif [[ ${#} -eq 2 ]]; then
        mount_sshfs "${1}" "${2}" && ST_MOUNTED_SINGLE=true
    elif [[ -n "${VOL_NAME}" ]]; then
        if get_session "${VOL_NAME}" > /dev/null; then
            mount_sshfs $(get_session "${VOL_NAME}") && ST_MOUNTED_SINGLE=true
        else
            ST_EXIT=1
        fi
    fi
fi

# TODO: ? prompt: Want an ssh session with that?

exit $(($? > ST_EXIT ? $? : ST_EXIT))
